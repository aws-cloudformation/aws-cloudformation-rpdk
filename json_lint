#!/usr/bin/env python3
import argparse
import json
import sys
from os.path import dirname, join
from subprocess import STDOUT, check_output

BASE_PATH = dirname(__file__).encode("utf-8")


def rewrite_json(path):
    with open(path, "r", encoding="utf-8") as f:
        data = json.load(f)
    with open(path, "w", encoding="utf-8") as f:
        json.dump(data, f, indent=4)
        f.write("\n")  # trailing newline as per POSIX


def check_json(path):
    with open(path, "r", encoding="utf-8") as f:
        raw = f.read()
    formatted = json.dumps(json.loads(raw), indent=4) + "\n"
    return formatted == raw


def main():
    parser = argparse.ArgumentParser()
    parser.add_argument(
        "--check",
        action="store_true",
        help="Don't write the files back, just return the status.",
    )
    args = parser.parse_args()

    tree = check_output(["git", "ls-files", "-z"], stderr=STDOUT)
    # note: filenames are kept as bytes where possible to avoid having to deal
    # with the OS'/filesystem's encoding
    return_code = 0
    for filename in tree.split(b"\0"):
        if filename.endswith(b".json"):
            path = join(BASE_PATH, filename)
            if args.check:
                if not check_json(path):
                    # can't use print if we want to keep the filename in bytes
                    sys.stdout.buffer.write(b"would reformat: ")
                    sys.stdout.buffer.write(filename)
                    sys.stdout.buffer.write(b"\n")
                    return_code = 1
            else:
                rewrite_json(path)

    return return_code


if __name__ == "__main__":
    sys.exit(main())

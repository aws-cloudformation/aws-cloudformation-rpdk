import logging

import pytest

# WARNING: contract tests should use fully qualified imports to avoid issues
# when being loaded by pytest
from rpdk.core.contract.interface import Action, HandlerErrorCode

LOG = logging.getLogger(__name__)


def contract_check_asserts_work():
    message = (
        "Asserts have been stripped. This is unusual, but happens if the "
        "contract tests are compiled to optimized byte code. As a result, the "
        "contract tests will not run correctly. Please raise an issue with "
        "as much information about your system and runtime as possible."
    )
    with pytest.raises(AssertionError):
        assert False  # noqa: B011
        pytest.fail(message)


def contract_crud_exerciser(resource_client):
    create_model = resource_client.generate_create_example()
    # We eventually update the resource under test, but if
    # something goes wrong, we want the delete handler to at
    # least be able to delete with the initial model.
    #
    # We retain the create model as a separate entity because
    # we'll later want to create a new resource from the same
    # model.
    updated_model = create_model

    number_of_resources_after_creation = 0

    try:
        create_response = _test_successful_create(resource_client, create_model)
        # Update the model to include values generated by the create handler.
        create_model = create_response["resourceModel"]
        updated_model = create_model

        _test_successful_read(resource_client, create_model)

        list_response = _test_successful_list(resource_client, create_model)
        number_of_resources_after_creation = len(list_response["resourceModels"])

        update_response = _test_successful_update(resource_client, create_model)

        updated_model = update_response["resourceModel"]

        # Read and list operations should work as expected after an update.
        _test_successful_read(resource_client, updated_model)

        _test_successful_list(resource_client, updated_model)
    finally:
        _test_successful_delete(resource_client, updated_model)

        _test_read_not_found(resource_client, updated_model)

        # LIST: Should not fail after deletion, since it is a list of all
        #       current resources of the resource type. Deletion should
        #       remove an item from the list, however.
        post_delete_list_response = _test_successful_list(
            resource_client, updated_model
        )
        assert (
            len(post_delete_list_response["resourceModels"])
            == number_of_resources_after_creation - 1
        )

        _test_update_not_found(resource_client, updated_model)

    # DELETE: Should fail with NotFound because we've already deleted the resource.
    _test_delete_not_found(resource_client, create_model)

    new_create_model = create_model
    try:
        # CREATE: Deleting the resource should not result in artifacts that
        #         prevent creation.
        new_create_model = _test_successful_create(resource_client, create_model)[
            "resourceModel"
        ]

    finally:
        # DELETE: Deleting a resource should not result in artifacts that
        #         later prohibit deletion.
        _test_successful_delete(resource_client, new_create_model)


def _test_successful_create(resource_client, current_resource_model):
    create_request = resource_client.make_request(current_resource_model, None)

    create_status, create_response = resource_client.call(Action.CREATE, create_request)
    resource_client.assert_success(create_status, create_response)

    # If no identifiers are writeable, then multiple requests with the same
    # model can succeed.
    if resource_client.has_writable_identifier():
        LOG.debug(
            "at least one identifier is writeable; "
            "performing duplicate-CREATE-failed test"
        )
        # Should fail, because different clientRequestToken for the same
        # resource model means that the same resource is trying to be
        # created twice.
        second_request = resource_client.make_request(current_resource_model, None)
        second_create_status, second_create_response = resource_client.call(
            Action.CREATE, second_request
        )
        error_code = resource_client.assert_failed(
            second_create_status, second_create_response
        )
        assert (
            error_code == HandlerErrorCode.AlreadyExists
        ), "creating the same resource should not be possible"

    else:
        LOG.debug(
            "no identifiers are writeable; " "skipping duplicate-CREATE-failed test"
        )
    return create_response


def _test_successful_read(resource_client, current_resource_model):
    read_request = resource_client.make_request(current_resource_model, None)
    read_status, read_response = resource_client.call(Action.READ, read_request)
    resource_client.assert_success(read_status, read_response)
    assert read_response["resourceModel"] == current_resource_model
    return read_response


def _test_successful_list(resource_client, current_resource_model):
    list_request = resource_client.make_request(current_resource_model, None)
    list_status, list_response = resource_client.call(Action.LIST, list_request)
    resource_client.assert_success(list_status, list_response)
    return list_response


def _test_successful_update(resource_client, current_resource_model):
    update_model = resource_client.generate_create_example()
    update_request = resource_client.make_request(current_resource_model, update_model)
    update_status, update_response = resource_client.call(Action.UPDATE, update_request)
    resource_client.assert_success(update_status, update_response)
    # The response model should be the same as the create output model,
    # except the update-able properties should be overridden.
    assert update_response["resourceModel"] == {
        **update_model,
        **current_resource_model,
    }
    return update_response


def _test_successful_delete(resource_client, current_resource_model):
    delete_request = resource_client.make_request(current_resource_model, None)
    delete_status, delete_response = resource_client.call(Action.DELETE, delete_request)
    resource_client.assert_success(delete_status, delete_response)


def _test_read_not_found(resource_client, current_resource_model):
    post_delete_read_request = resource_client.make_request(
        current_resource_model, None
    )
    post_delete_read_status, post_delete_read_response = resource_client.call(
        Action.READ, post_delete_read_request
    )
    error_code = resource_client.assert_failed(
        post_delete_read_status, post_delete_read_response
    )
    assert error_code == HandlerErrorCode.NotFound


def _test_update_not_found(resource_client, current_resource_model):
    post_delete_update_model = resource_client.generate_create_example()
    post_delete_update_request = resource_client.make_request(
        current_resource_model, post_delete_update_model
    )
    post_delete_update_status, post_delete_update_response = resource_client.call(
        Action.UPDATE, post_delete_update_request
    )
    error_code = resource_client.assert_failed(
        post_delete_update_status, post_delete_update_response
    )
    assert error_code == HandlerErrorCode.NotFound


def _test_delete_not_found(resource_client, current_resource_model):
    not_found_delete_request = resource_client.make_request(
        current_resource_model, None
    )
    not_found_delete_status, not_found_delete_response = resource_client.call(
        Action.DELETE, not_found_delete_request
    )
    error_code = resource_client.assert_failed(
        not_found_delete_status, not_found_delete_response
    )
    assert error_code == HandlerErrorCode.NotFound
